        !*************************************************************!
        !*      META-FES-EXTRACT.1.1                                 *!
        !*                                                           *!
        !*      A PARALLEL IMPLEMENTATION OF METADYNAMICS FREE       *!
        !*      ENERGY SURFACE CONSTRUCTION.                         *!
        !*                                                           *!
        !*      DEVELOPED BY VENKAT KAPIL                            *!
        !*      CONTACT : venkat@iitk.ac.in                          *!
        !*                                                           *!
        !*      COPYRIGHT (C) 2015 VENKAT KAPIL                      *!
        !*      SOME RIGHTS RESERVED.                                *!
        !*                                                           *!
        !*************************************************************!

        !*****************************************************************************************!
	!>>>>>> SUBROUTINES <<<<<<<!
        !*****************************************************************************************!

	!INPUTS METADYNAMICS AND GRID PARAMETERS.
	SUBROUTINE INPUT
	USE GLOBAL_VAR
	IMPLICIT NONE
	INCLUDE 'mpif.h'
	CHARACTER (LEN=200) TOKEN, COMMENT, GRID
	INTEGER ITER1, ITER2
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$!	
	!#IF DEFINED (_PARALLEL) 
	!READS FROM FILE ONLY IN PARENT PROCESSOR. 
	IF (MPIRANK .EQ. 0) THEN
	!#ENDIF
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$!
	!OPENS FILE.
		OPEN (UNIT = 1, FILE = INPUTFILE, STATUS ='OLD')
	!READS NUMBER OF DIMENSIONS AND CHECKS FOR ERROR.
		READ (1,*) TOKEN, NDIM
		IF (NDIM .LT. 1) THEN
			CALL PRINT_ERROR ('ERROR IN NUMBER OF DIMENSIONS.') 
			ERRORSTAT = .TRUE.
			RETURN
		ENDIF
	!INPUTS GRID PARAMETERS ABD CHECKS FOR ERROR. 
		CALL ALLOCATE_ALL_GRID
		READ (1,*) TOKEN
		NGRID = 1
		DO ITER1 = 1,NDIM
			READ (1,*) GRIDMIN(ITER1), GRIDMAX(ITER1), GRIDDIF(ITER1)
			
			NBIN(ITER1) =(GRIDMAX(ITER1) - GRIDMIN(ITER1)) / GRIDDIF(ITER1) + 1
			IF (NBIN(ITER1) .LE. 0) THEN
				CALL PRINT_ERROR ('ERROR IN GRID DETAILS.') 
				ERRORSTAT = .TRUE.
				RETURN
			ENDIF
			NGRID= NGRID*NBIN(ITER1) 
		ENDDO
	!READS THE PACKAGE USED FOR METADYNAMICS AND CHECKS FOR ERROR.
		READ(1,*) TOKEN, PACKAGE
		IF ((PACKAGE .LT. 1) .OR. (PACKAGE .GT. 3)) THEN
			CALL PRINT_ERROR('ERROR IN PACKAGE CODE')
			ERRORSTAT = .TRUE.
			RETURN
		ENDIF
	!READS NUMBER OF HILLS AND CHECKS FOR ERROR.
		READ(1,*) TOKEN, NHILL
        		IF (NHILL .LT. 1) THEN
        			CALL PRINT_ERROR ('ERROR IN NUMBER OF METADYNAMICS STEPS.') 
        			ERRORSTAT = .TRUE.
        		RETURN
        		ENDIF
	!INPUTS NUMBER OF NETADYNAMICS COLLECTIVE VARIABLES AND CHECKS FOR ERROR.
		READ(1,*) TOKEN, NMETACOLVAR
		IF (NMETACOLVAR .LT. 1) THEN
			CALL PRINT_ERROR ('ERROR IN NUMBER OF METADYNAMICS COLLECTIVE VARIABLES.') 
			ERRORSTAT = .TRUE.
			RETURN
		ENDIF
	!INPUTS INDEX OF METADYNAMICS COLLECTIVE VARIABLES AND CHECKS FOR ERROR.
		CALL ALLOCATE_ALL_MTD01
		READ(1,*) TOKEN
		READ(1,*) (IMETACOLVAR(ITER1), ITER1 = 1,NMETACOLVAR)
		DO ITER1 = 1,NMETACOLVAR
			IF ((IMETACOLVAR(ITER1) .LT. 1) .OR. (IMETACOLVAR(ITER1) .GT. NDIM)) THEN
				CALL PRINT_ERROR ('ERROR IN INDEX/INDICES OF METADYNAMICS COLLECTIVE VARIABLE(S).') 
				ERRORSTAT = .TRUE.
				RETURN
			ENDIF
			DO ITER2 = ITER1, NMETACOLVAR
				IF (IMETACOLVAR(ITER1) .NE. IMETACOLVAR(ITER2)) THEN
					CALL PRINT_ERROR ('ERROR IN INDEX/INDICES OF METADYNAMICS COLLECTIVE VARIABLE(S).')
					ERRORSTAT = .TRUE.
					RETURN
				ENDIF
			ENDDO
		ENDDO
		CALL ALLOCATE_ALL_MTD02
	!READS TEMPERATURE AND APLHA AND CHECKS FOR ERROR.
		READ (1,*) TOKEN, TEMP, WTALPHA
		IF (TEMP .LE. 0.0D0) THEN
			CALL PRINT_ERROR ('ERROR IN TEMPERATURE.')
			ERRORSTAT = .TRUE.
			RETURN
		ENDIF
		IF (WTALPHA .LE. 0.0D0) THEN
			CALL PRINT_ERROR('ERROR IN BIASING TEMPERATURE.')
			ERRORSTAT =.TRUE.
			RETURN
		ENDIF
		TEMP = TEMP/3.1577464D5
		IF (WTALPHA -1.0D0  .GT. 0.0001D0) THEN
			WELLTEMP = .TRUE.
			WTDT = TEMP / (WTALPHA - 1.0D0)
		ENDIF
	!READS THE FREQUENCY AT WHICH CHANGE IN REWEIGHTING FACTOR IS RECORDED AND CHECKS FOR ERROR.
		READ (1,*) TOKEN, CDUMP
		IF (CDUMP .LE. 0) THEN
			CALL PRINT_ERROR ('ERROR IN PRINTING FREQUENCY OF REWEIGHTING FACTOR')
		ENDIF
		CALL ALLOCATE_ALL_REWT
	!READS THE RANGE OF INTEGRATION FOR REWEIGHTING AND CHECKS FOR ERROR.
		READ(1,*) TOKEN, NHILLMIN, NHILLMAX
		IF (NHILLMIN .LE. 0) THEN
                	CALL PRINT_ERROR ('ERROR IN RANGE OF INTEGRATION FOR REWEIGHTING FACTOR')
                ENDIF
		IF (NHILLMAX .LE. 0) THEN                                                        	
                	CALL PRINT_ERROR ('ERROR IN RANGE OF INTEGRATION FOR REWEIGHTING FACTOR')
                ENDIF
		IF (NHILLMAX - NHILLMIN .LE. 0) THEN
                	CALL PRINT_ERROR ('ERROR IN RANGE OF INTEGRATION FOR REWEIGHTING FACTOR')
	        ENDIF
	!READS THE SMOOTHENING FACTOR AND CHECKS FOR ERROR.
		READ(1,*) TOKEN, FSMOOTH
		CLOSE (1)
	ENDIF
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$!  
	!#IF DEFINED(_PARALLEL) 
	!WAITS FOR OTHER PROCESSORS.. 
	CALL MPI_BARRIER (MPI_COMM_WORLD,MPIERROR)
	!SHARES ALL NON-ARRAY GRID VARIABLES WITH ALL PROCESSORS.
	!INTEGER TYPE VARIABLES.
	CALL MPI_BCAST (NDIM		, 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	CALL MPI_BCAST (NGRID		, 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	IF (MPIERROR .NE. MPI_SUCCESS) THEN
                CALL PRINT_ERROR ('ERROR IN MPI BCAST OF ONE OF NON ARRAY GRID VARIABLES.')
                ERRORSTAT = .TRUE.
                CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
		RETURN
        ENDIF
	!ALLOCATES ALL ARRAY GRID VARIABLES IN PROCESSORS OTHER THAN PARENT.
	IF (MPIRANK .NE. 0) THEN
	        CALL ALLOCATE_ALL_GRID
	ENDIF
	!SHARES ALL ARRAY GRID TYPE VARIABLES WITH ALL PROCESSORS.
	!INTEGER TYPE.
	CALL MPI_BCAST (NBIN		, NDIM			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	!REAL TYPE.
	CALL MPI_BCAST (GRIDMIN		, NDIM			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
	CALL MPI_BCAST (GRIDMAX		, NDIM			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
	CALL MPI_BCAST (GRIDDIF		, NDIM			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
	IF (MPIERROR .NE. MPI_SUCCESS) THEN
                CALL PRINT_ERROR ('ERROR IN MPI BCAST OF ONE OF ARRAY GRID VARIABLES.')
                ERRORSTAT = .TRUE.
                CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
		RETURN
        ENDIF
	!#ENDIF
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$!  
	!UPDATES LOG FILE IN PARENT PROCESSOR.
	IF (MPIRANK .EQ. 0) THEN
		OPEN (UNIT = 1, FILE = LOGFILE, ACCESS = 'APPEND', STATUS = 'OLD')
		WRITE(1,*) 
	!PRINTS THE DIMENSIONS.
		WRITE(1,'(A,T50,A,I2)') 'NUMER OF DIMENSIONS', ':  ', NDIM
	!PRINTS THE GRID.
		GRID = ''
		DO ITER1 = 1,NDIM - 1
			WRITE (COMMENT,'(I5,A)') NBIN(ITER1), ' x'
			GRID =  TRIM (GRID) // COMMENT
		ENDDO
		WRITE (COMMENT,'(I5,A)') NBIN(ITER1), ' '
		WRITE(1,'(A,T50,A,A)') 'GRID', ':  ', ADJUSTL (TRIM (TRIM (GRID) // COMMENT))
	!PRINTS THE RANGE,
		GRID = '['
		ITER1 = 1
		WRITE (COMMENT,'(F8.5,A,F8.5)') GRIDMIN(ITER1), ', ', GRIDMAX(ITER1)
                GRID =  TRIM (GRID) // COMMENT
		DO ITER1 = 2,NDIM
			GRID =  TRIM (GRID) // ':'
			WRITE (COMMENT,'(F8.5,A,F8.5)') GRIDMIN(ITER1), ', ', GRIDMAX(ITER1)
			GRID =  TRIM (GRID) // COMMENT
		ENDDO
        	GRID =  TRIM (GRID) // ']'
		WRITE(1,'(A,T50,A,A)') 'RANGE', ':  ', ADJUSTL (TRIM (GRID))
		CLOSE(1)
	ENDIF
	RETURN
	END SUBROUTINE
        !*****************************************************************************************!

	!INPUTS METADYNAMICS PARAMETERS, CALCULATES RANGE OF INTEGRATION.
        SUBROUTINE INPUT_HILLS
        USE GLOBAL_VAR
        IMPLICIT NONE
        INCLUDe 'mpif.h'
        INTEGER ITER1, ITER2, IOSTATUS1, IOSTATUS2
        REAL*8 DUMMY1, SMIN, SMAX
        !#IF DEFINED (_PARALLEL)
        !READS HILLS ONLY IN PARENT PROCESSOR. 
        IF( MPIRANK .EQ. 0 ) THEN
        !INPUT PROCEDURE FOR PLUMED.
        	IF( PACKAGE .EQ. 2) THEN
        		OPEN (UNIT = 1, FILE =  'HILLFILES/HILLS', STATUS = 'OLD') 
        !READS HILL PARAMETERS.
        		DO ITER1 = 1,NHILL
        			READ (1,*,IOSTAT = IOSTATUS1) TIME(ITER1), (CENTER(ITER2,ITER1), ITER2 = 1,NMETACOLVAR), WIDTH(ITER1), HEIGHT(ITER1) 
        !CHECKS FOR EOF OR CORRUPT INPUT.
        			IF(IOSTATUS1 .GT. 0) THEN
        				CALL PRINT_ERROR ('CORRUPT VALUES READ FROM HILLFILES/HILLS.')
        				ERRORSTAT = .TRUE.
        				EXIT
        			ELSE IF(IOSTATUS1 .LT. 0) THEN
        				CALL PRINT_ERROR ('PREMATURE END OF HILLFILES/HILLS.')
        				ERRORSTAT = .TRUE.
        				EXIT
        			ELSE
        !RESCALES THE HEIGHT.
        				HEIGHT(ITER1) = HEIGHT(ITER1) / WTALPHA
        !FINDS THE STARTING POINT  OF INTEGRATION.
        				S(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)) = CENTER(1:NMETACOLVAR,ITER1) - 5.0D0 * WIDTH(ITER1)
        				CALL GETIS
        				IMIN(1:NMETACOLVAR,ITER2) = MAX (0,I(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)))
        !FINDS THE END POINT  OF INTEGRATION.
        				S(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)) = CENTER(1:NMETACOLVAR,ITER1) + 5.0D0 * WIDTH(ITER1)
        				CALL GETIS
        				IMAX(1:NMETACOLVAR,ITER2) = MIN (NBIN(1:NMETACOLVAR),I(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)))
        			ENDIF
        		ENDDO
        		CLOSE(1)
        !INPUT PROCEDURE FOR CPMD.
        	ELSEIF (PACKAGE .EQ. 1) THEN
        		OPEN (UNIT = 1, FILE = 'HILLFILES/colvar_mtd', STATUS = 'OLD')
        		OPEN (UNIT = 2, FILE = 'HILLFILES/parvar_mtd', STATUS = 'OLD')
        !READS HILL PARAMETERS.
        		DO ITER1 = 1,NHILL
        			READ (1,*,IOSTAT = IOSTATUS1) TIME(ITER1), (CENTER(ITER2,ITER1), ITER2 = 1,NMETACOLVAR), (DUMMY1, ITER2=1,NMETACOLVAR)
        			READ (2,*,IOSTAT = IOSTATUS2) DUMMY1, DUMMY1, WIDTH(ITER1), HEIGHT(ITER1)
        !CHECKS FOR EOF OR CORRUPT INPUT.
        			IF (IOSTATUS1 .GT. 0) THEN
        				CALL PRINT_ERROR ('CORRUPT VALUES READ FROM HILLFILES/colvar_mtd.')
        				ERRORSTAT = .TRUE.
        				EXIT
        			ELSEIF (IOSTATUS2 .GT. 0) THEN
        				CALL PRINT_ERROR ('CORRUPT VALUES READ FROM HILLFILES/parvar_mtd.')
        				ERRORSTAT = .TRUE.
        				EXIT
        			ELSEIF(IOSTATUS1 .LT. 0) THEN
        				CALL PRINT_ERROR ('PREMATURE END OF HILLFILES/colvar_mtd')
        				ERRORSTAT = .TRUE.
          				EXIT
        			ELSEIF(IOSTATUS2 .LT. 0) THEN
        				CALL PRINT_ERROR ('PREMATURE END OF HILLFILES/parvar_mtd')
        				ERRORSTAT = .TRUE.
        				EXIT
        			ELSE
        !RESCALES THE HEIGHT.
        				HEIGHT(ITER1) = HEIGHT(ITER1) / WTALPHA
        !FINDS THE STARTING POINT  OF INTEGRATION.
        				S(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)) = CENTER(1:NMETACOLVAR,ITER1) - 5.0D0 * WIDTH(ITER1)
        				CALL GETIS
        				IMIN(1:NMETACOLVAR,ITER1) = MAX (0,I(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)))
        !FINDS THE END POINT  OF INTEGRATION.
        				S(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)) = CENTER(1:NMETACOLVAR,ITER1) + 5.0D0 * WIDTH(ITER1)
        				CALL GETIS
        				IMAX(1:NMETACOLVAR,ITER1) = MIN (NBIN(1:NMETACOLVAR),I(1:NDIM))
        			ENDIF
        		ENDDO
        		CLOSE(1)
        		CLOSE(2)
	!INPUT PROCEDURE FOR TOYCODE-1.0.
        	ELSEIF (PACKAGE .EQ. 3) THEN
        		OPEN (UNIT = 1, FILE =  'HILLFILES/RESTART_META', STATUS = 'OLD') 
        !READS HILL PARAMETERS.
        		DO ITER1 = 1,NHILL
        			READ (1,*,IOSTAT = IOSTATUS1) TIME(ITER1), DUMMY1, (CENTER(ITER2,ITER1), ITER2 = 1,NMETACOLVAR),  HEIGHT(ITER1), WIDTH(ITER1), DUMMY1
        !CHECKS FOR EOF OR CORRUPT INPUT.
        			IF(IOSTATUS1 .GT. 0) THEN
        				CALL PRINT_ERROR ('CORRUPT VALUES READ FROM HILLFILES/HILLS.')
        				ERRORSTAT = .TRUE.
        				EXIT
        			ELSE IF(IOSTATUS1 .LT. 0) THEN
        				CALL PRINT_ERROR ('PREMATURE END OF HILLFILES/HILLS.')
        				ERRORSTAT = .TRUE.
        				EXIT
        			ELSE
        !RESCALES THE HEIGHT.
        				HEIGHT(ITER1) = HEIGHT(ITER1) / WTALPHA
        !FINDS THE STARTING POINT  OF INTEGRATION.
        				S(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)) = CENTER(1:NMETACOLVAR,ITER1) - 5.0D0 * WIDTH(ITER1)
       					CALL GETIS
        				IMIN(1:NMETACOLVAR,ITER1) = MAX (0,I(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)))
        !FINDS THE END POINT  OF INTEGRATION.
        				S(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)) = CENTER(1:NMETACOLVAR,ITER1) + 5.0D0 * WIDTH(ITER1)
        				CALL GETIS
        				IMAX(1:NMETACOLVAR,ITER1) = MIN (NBIN(IMETACOlVAR(1):IMETACOLVAR(NMETACOLVAR)),I(IMETACOLVAR(1):IMETACOLVAR(NMETACOLVAR)))
        			ENDIF
        		ENDDO
        		CLOSE(1)
		ENDIF
        ENDIF
        !#IF DEFINED(_PARALLEL)
        !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$! 
        !WAITS FOR ALL PROCESSORS.
        CALL MPI_BARRIER (MPI_COMM_WORLD,MPIERROR)
        !SHARES ALL NON ARRAY METADYNAMICS VARIABLES WITH OTHER PROCESSORS.
        !INTEGER TYPE VARIABLES.
        CALL MPI_BCAST (NMETACOLVAR	, 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (NHILL   	, 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (PACKAGE 	, 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (CDUMP   	, 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        !REAL TYPE VARIABLES.
        CALL MPI_BCAST (TEMP    	, 1			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (WTDT    	, 1			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (WTALPHA 	, 1			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        !LOGICAL VARIABLES VARIABLES.
        CALL MPI_BCAST (WELLTEMP	, 1			, MPI_LOGICAL		, 0, MPI_COMM_WORLD, MPIERROR)
        IF (MPIERROR .NE. MPI_SUCCESS) THEN
                CALL PRINT_ERROR ('ERROR IN MPI BCAST OF ONE OF NON ARRAY METADYNAMICS VARIABLES.')
                ERRORSTAT = .TRUE.
                CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
                RETURN
        ENDIF
        !ALLOCATES ALL ARRAY METADYNAMICS VARIABLES IN PROCESSORS OTHER THAN PARENT.
        IF (MPIRANK .NE. 0) THEN
                CALL ALLOCATE_ALL_MTD01
        ENDIF
        !SHARES ALL ARRAY METADYNAMICS TYPE VARIABLES WITH ALL PROCESSORS.
        !INTEGER TYPE VARIABLES.
        CALL MPI_BCAST (IMETACOLVAR	, NMETACOLVAR		, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (TIME		, NHILL			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (IMIN    	, NMETACOLVAR * NHILL	, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (IMAX    	, NMETACOLVAR * NHILL   , MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        !REAL TYPE VARIABES.
        CALL MPI_BCAST (WIDTH   	, NHILL          	, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (HEIGHT  	, NHILL          	, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (CENTER  	, NMETACOLVAR * NHILL   , MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        IF (MPIERROR .NE. MPI_SUCCESS) THEN
                CALL PRINT_ERROR ('ERROR IN MPI BCAST OF ONE OF ARRAY METADYNAMICS VARIABLES.')
                ERRORSTAT = .TRUE.
                CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
        	RETURN
        ENDIF
	!ALLOCATES ALL ARRAY METADYNAMICS VARIABLES IN PROCESSORS OTHER THAN PARENT.
        IF (MPIRANK .NE. 0) THEN
                CALL ALLOCATE_ALL_MTD02
		CALL ALLOCATE_ALL_REWT
        ENDIF
	!SHARES ALL REWEIGHTING AVRIABLES WITH ALL PROCESSORS.
	!INTEGR TYPE.
	!CALL MPI_BCAST (HEIGHT  	, 1       	, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	!CALL MPI_BCAST (CENTER  	, 1		, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	IF (MPIERROR .NE. MPI_SUCCESS) THEN
	        CALL PRINT_ERROR ('ERROR IN MPI BCAST OF ONE OF NON ARRAY REWEIGHTING VARIABLES.')
	        ERRORSTAT = .TRUE.
	        CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
		RETURN
	ENDIF
        !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$! 
        !#ENDIF
        !UPDATES LOG FILE IN PARENT PROCESSOR.
        IF (MPIRANK .EQ. 0) THEN
        	OPEN (UNIT = 1, FILE = LOGFILE, ACCESS = 'APPEND', STATUS = 'OLD')
        	WRITE(1,*)
        	WRITE(1,'(A,T40,A,I5)') 'NUMBER OF GAUSSIANS', ':  ', NHILL
        	WRITE(1,'(A,T40,A,F10.5)') 'INITIAL HEIGHT OF GAUSSIANS (a.u.)', ':  ', HEIGHT(1)
        	WRITE(1,'(A,T40,A,F10.5)') 'INITIAL WIDTH  OF GAUSSIANS (a.u.)', ':  ', WIDTH(1)
        	IF (WELLTEMP .EQV. .TRUE.) THEN
        		WRITE(1,'(A,T40,A,F10.5)') 'BIASING TEMPERATURE (K)', ':  ', WTDT * 3.1577464D5
        	ENDIF
        	WRITE(1,'(A,T40,A,I5,A)') 'PRINTING C(T) EVERY ', ':  ', CDUMP, ' STEP(S)'
        	CLOSE(1)
        ENDIF
        RETURN 
        END SUBROUTINE
        !*****************************************************************************************!
        !*****************************************************************************************!
	!>>>>>> SUBROUTINES <<<<<<<!
        !*****************************************************************************************!
