        !*************************************************************!
        !*      SUM_HILLS-1.                                         *!
        !*                                                           *!
        !*      A PARALLEL IMPLEMENTATION OF METADYNAMICS FREE       *!
        !*      ENERGY SURFACE CONSTRUCTION.                         *!
        !*                                                           *!
        !*      DEVELOPED BY VENKAT KAPIL                            *!
        !*      CONTACT : venkat@iitk.ac.in                          *!
        !*                                                           *!
        !*      COPYRIGHT (C) 2015 VENKAT KAPIL                      *!
        !*      SOME RIGHTS RESERVED.                                *!
        !*                                                           *!
        !*************************************************************!

	!*****************************************************************************************!
	!>>>>>> SUBROUTINES <<<<<<<!
	!*****************************************************************************************!
	
	!INPUTS METADYNAMICS PARAMETERS, CALCULATES RANGE OF INTEGRATION AND ADDS BIAS.
	SUBROUTINE INPUT_HILLS
	USE GLOBAL_VAR
	IMPLICIT NONE
	INCLUDe 'mpif.h'
	INTEGER ITER1, ITER2, IOSTATUS1, IOSTATUS2
	REAL*8 DUMMY1, SMIN, SMAX
	!#IF DEFINED (_PARALLEL)
	!READS HILLS ONLY IN PARENT PROCESSOR. 
	IF( MPIRANK .EQ. 0 ) THEN
	!INPUT PROCEDURE FOR PLUMED.
		IF( PACKAGE .EQ. 2) THEN
			OPEN (UNIT = 1, FILE =  'HILLFILES/HILLS', STATUS = 'OLD') 
	!READS HILL PARAMETERS.
			DO ITER1=1,NMTD
				READ (1,*,IOSTAT = IOSTATUS1) DUMMY1, (CENTER(ITER2,ITER1), ITER2 = 1,NDIM), WIDTH(ITER1), HEIGHT(ITER1) 
	!CHECKS FOR EOF OR CORRUPT INPUT.
				IF(IOSTATUS1 .GT. 0) THEN
					CALL PRINT_ERROR ('CORRUPT VALUES READ FROM HILLFILES/HILLS.')
					ERRORSTAT = .TRUE.
					EXIT
				ELSE IF(IOSTATUS1 .LT. 0) THEN
					CALL PRINT_ERROR ('PREMATURE END OF HILLFILES/HILLS.')
					ERRORSTAT = .TRUE.
					EXIT
				ELSE
	!RESCALES THE HEIGHT.
					HEIGHT = HEIGHT / WTALPHA
	!FINDS THE STARTING POINT  OF INTEGRATION.
					S(1:NDIM) = CENTER(1:NDIM,ITER1) - 5.0D0 * WIDTH(ITER1)
					CALL GETI
					IMIN(1:NDIM,ITER2) = MAX (0,I(1:NDIM))
	!FINDS THE END POINT  OF INTEGRATION.
					S(1:NDIM) = CENTER(1:NDIM,ITER1) + 5.0D0 * WIDTH(ITER1)
					CALL GETI
					IMAX(1:NDIM,ITER2) = MIN (I(1:NDIM),I(1:NDIM))
				ENDIF
			ENDDO
			CLOSE(1)
	!INPUT PROCEDURE FOR CPMD.
		ELSEIF( PACKAGE .EQ. 1) THEN
			OPEN (UNIT = 1, FILE = 'HILLFILES/colvar_mtd', STATUS = 'OLD')
			OPEN (UNIT = 2, FILE = 'HILLFILES/parvar_mtd', STATUS = 'OLD')
        !READS HILL PARAMETERS.
			DO ITER1=1,NMTD
				READ (1,*,IOSTAT = IOSTATUS1) DUMMY1, (CENTER(ITER2,ITER1), ITER2 = 1,NDIM), (DUMMY1, ITER2=1,NDIM)
				READ (2,*,IOSTAT = IOSTATUS2) DUMMY1, DUMMY1, WIDTH(ITER1), HEIGHT(ITER1)
        !CHECKS FOR EOF OR CORRUPT INPUT.
				IF (IOSTATUS1 .GT. 0) THEN
					CALL PRINT_ERROR ('CORRUPT VALUES READ FROM HILLFILES/colvar_mtd.')
					ERRORSTAT = .TRUE.
					EXIT
				ELSEIF (IOSTATUS2 .GT. 0) THEN
					CALL PRINT_ERROR ('CORRUPT VALUES READ FROM HILLFILES/parvar_mtd.')
					ERRORSTAT = .TRUE.
					EXIT
				ELSEIF(IOSTATUS1 .LT. 0) THEN
					CALL PRINT_ERROR ('PREMATURE END OF HILLFILES/colvar_mtd')
					ERRORSTAT = .TRUE.
	  				EXIT
				ELSEIF(IOSTATUS2 .LT. 0) THEN
					CALL PRINT_ERROR ('PREMATURE END OF HILLFILES/parvar_mtd')
					ERRORSTAT = .TRUE.
					EXIT
				ELSE
        !RESCALES THE HEIGHT.
					HEIGHT(ITER1) = HEIGHT(ITER1) / WTALPHA
        !FINDS THE STARTING POINT  OF INTEGRATION.
					S(1:NDIM) = CENTER(1:NDIM,ITER1) - 5.0D0 * WIDTH(ITER1)
					CALL GETI
					IMIN(1:NDIM,ITER1) = MAX (0,I(1:NDIM))
        !FINDS THE END POINT  OF INTEGRATION.
					S(1:NDIM) = CENTER(1:NDIM,ITER1) + 5.0D0 * WIDTH(ITER1)
					CALL GETI
					IMAX(1:NDIM,ITER1) = MIN (NBIN(1:NDIM),I(1:NDIM))
				ENDIF
			ENDDO
			CLOSE(1)
			CLOSE(2)
		ENDIF
	ENDIF
	!#IF DEFINED(_PARALLEL)
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$! 
	!WAITS FOR ALL PROCESSORS.
	CALL MPI_BARRIER (MPI_COMM_WORLD,MPIERROR)
	!SHARES ALL NON ARRAY METADYNAMICS VARIABLES WITH OTHER PROCESSORS.
	!INTEGER TYPE VARIABLES.
	CALL MPI_BCAST (NMTD    , 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (PACKAGE , 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (CDUMP   , 1			, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	!REAL TYPE VARIABLES.
        CALL MPI_BCAST (TEMP    , 1			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (WTDT    , 1			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        CALL MPI_BCAST (WTALPHA , 1			, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        !LOGICAL VARIABLES VARIABLES.
        CALL MPI_BCAST (WELLTEMP, 1			, MPI_LOGICAL		, 0, MPI_COMM_WORLD, MPIERROR)
	IF (MPIERROR .NE. MPI_SUCCESS) THEN
                CALL PRINT_ERROR ('ERROR IN MPI BCAST OF ONE OF NON ARRAY METADYNAMICS VARIABLES.')
                ERRORSTAT = .TRUE.
                CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
                RETURN
	ENDIF
	!ALLOCATES ALL ARRAY METADYNAMICS VARIABLES IN PROCESSORS OTHER THAN PARENT.
        IF (MPIRANK .NE. 0) THEN
                CALL ALLOCATE_ALL_MTD
        ENDIF
        !SHARES ALL ARRAY METADYNAMICS TYPE VARIABLES WITH ALL PROCESSORS.
        !INTEGER TYPE VARIABLES..
	CALL MPI_BCAST (IMIN    , NDIM * NMTD		, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	CALL MPI_BCAST (IMAX    , NDIM * NMTD   	, MPI_INTEGER		, 0, MPI_COMM_WORLD, MPIERROR)
	!REAL TYPE VARIABES.
	CALL MPI_BCAST (WIDTH   , NMTD          	, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
	CALL MPI_BCAST (HEIGHT  , NMTD          	, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
	CALL MPI_BCAST (CENTER  , NDIM * NMTD   	, MPI_DOUBLE_PRECISION	, 0, MPI_COMM_WORLD, MPIERROR)
        IF (MPIERROR .NE. MPI_SUCCESS) THEN
                CALL PRINT_ERROR ('ERROR IN MPI BCAST OF ONE OF ARRAY METADYNAMICS VARIABLES.')
                ERRORSTAT = .TRUE.
                CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
		RETURN
        ENDIF
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$! 
	!#ENDIF
	!UPDATES LOG FILE IN PARENT PROCESSOR.
	IF (MPIRANK .EQ. 0) THEN
		OPEN (UNIT = 1, FILE = LOGFILE, ACCESS = 'APPEND', STATUS = 'OLD')
		WRITE(1,*)
		WRITE(1,'(A,T40,A,I5)') 'NUMBER OF GAUSSIANS', ':  ', NMTD
		WRITE(1,'(A,T40,A,F10.5)') 'INITIAL HEIGHT OF GAUSSIANS (a.u.)', ':  ', HEIGHT(1)
		WRITE(1,'(A,T40,A,F10.5)') 'INITIAL WIDTH  OF GAUSSIANS (a.u.)', ':  ', WIDTH(1)
		IF (WELLTEMP .EQV. .TRUE.) THEN
			WRITE(1,'(A,T40,A,F10.5)') 'BIASING TEMPERATURE (a.u.)', ':  ', WTDT
		ENDIF
		WRITE(1,'(A,T40,A,I5,A)') 'PRINTING C(T) EVERY ', ':  ', CDUMP, ' STEP(S)'
		CLOSE(1)
	ENDIF
	RETURN 
	END SUBROUTINE
	!*****************************************************************************************!

	!CHOOSES SUBROUTINE FOR CALCULATINGMETADYNAMICS BIAS.
	SUBROUTINE CALC_HILLS
	USE GLOBAL_VAR
	IMPLICIT NONE
	!FOR 1D METADYNAMICS.
	IF (NDIM .EQ. 1) CALL CALC_HILLS_1D
	RETURN
	END SUBROUTINE
	!*****************************************************************************************!

	!CALCULATES 1-D METADYNAMICS BIAS.
	SUBROUTINE CALC_HILLS_1D
	USE GLOBAL_VAR
	IMPLICIT NONE
	INCLUDE 'mpif.h'
	INTEGER ITER1, ITER2, IBIAS
	REAL*8 DIFSQ
	INTEGER, DIMENSION(:), ALLOCATABLE :: IBEGIN, IEND
	character (len=100) filename
	ALLOCATE (IBEGIN(NDIM), IEND(NDIM))
	!INTEGRATES OVER HILLS.
	DO ITER1 = 1,NMTD
	!FINDS RANGE OF INTEGERATION.
	!	#IF DEFINED (_SERIAL) 
			IBEGIN(1) = IMIN(1,ITER1)
			IEND(1) = IMAX(1,ITER1)
	!	#ELSE
			IF (MOD (NBIN(1),MPITASKS) .EQ. 0) THEN
				MPIBIN(1) = NBIN(1) / MPITASKS
				IBEGIN(1) = MAX (MPIRANK * MPIBIN(1) + 1, IMIN(1,ITER1)) 
				IEND(1)   = MIN ((MPIRANK + 1) * MPIBIN(1), IMAX(1,ITER1))
			ELSE
				MPIBIN(1) = NBIN(1) / MPITASKS
				IF (MPIRANK .NE. MPITASKS - 1) THEN
					IBEGIN(1) = MAX (MPIRANK * MPIBIN(1) + 1, IMIN(1,ITER1))
					IEND(1)   = MIN ((MPIRANK + 1) * MPIBIN(1), IMAX(1,ITER1))
				ELSE
					
					IBEGIN(1) = MAX (MPIRANK * MPIBIN(1) + 1, IMIN(1,ITER1))
					IEND(1)   = MIN (NBIN(1), IMAX(1,ITER1))
				ENDIF
			ENDIF
	!	#ENDIF
	!INTEGRATES OVER GRIDS.
		I(1) = IBEGIN(1) - 1
		CALL MPI_BARRIER(MPI_COMM_WORLD, MPIERROR)
		DO 
	!UPDATES GRID POINT.
			I(1) = I(1) + 1
	!BAIL OUT.
			IF (I(1) .GT. IEND(1)) EXIT
	!UPDATES THE BIAS AND REWEIGHTING FACTOR.
			ITER2= IBIAS ()
			CNUM = CNUM - DEXP (BIAS(ITER2) / TEMP)
			CDEN = CDEN - DEXP (BIAS(ITER2) / TEMP * (WTALPHA-1.0D0))
			BIAS(ITER2) = BIAS(ITER2) + HEIGHT(ITER1) * DEXP (-0.50D0*DIFSQ (ITER1)/WIDTH(ITER1)/WIDTH(ITER1))
			CNUM = CNUM + DEXP (BIAS(ITER2) / TEMP)
			CDEN = CDEN + DEXP (BIAS(ITER2) / TEMP * (WTALPHA-1.0D0))
		ENDDO
	!STORES NUMERATOR AND DENOMENATOR OF REWEIGHTING FACTOR EVERY CDUMP STEPS.            	
        	IF (MOD(ITER1,CDUMP) .EQ. 0) THEN
        		CNUMER(ITER1 / CDUMP) = CNUM
        		CDENOM(ITER1 / CDUMP) = CDEN
        		IF( CDENOM(ITER1/CDUMP) .LT. 1.0) WRITE(*,*) DEXP (BIAS(ITER2) / TEMP)
        	ENDIF
	ENDDO
	!#IF DEFINED(_PARALLEL)
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$!
	!PATCHES VARIOUS SUB GRIDS.
	!CALCULATES TOTAL BIAS.
	CALL MPI_BARRIER(MPI_COMM_WORLD, MPIERROR)
	CALL MPI_ALLREDUCE (BIAS	, TBIAS	 , GRIDSIZE		, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, MPIERROR)
	IF (MPIERROR .NE. MPI_SUCCESS) THEN
		CALL PRINT_ERROR ('ERROR IN CALCULATION OF TOTAL BIAS.')
                ERRORSTAT = .TRUE.
                CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
                RETURN
	ENDIF
	!CALCULATES TOTAL REWEIGHTING FACTOR.
	CALL MPI_ALLREDUCE (CNUMER	, TCNUMER, NMTD / CDUMP 	, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, MPIERROR)
	CALL MPI_ALLREDUCE (CDENOM	, TCDENOM, NMTD / CDUMP 	, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, MPIERROR)
	IF(MPIERROR .NE. MPI_SUCCESS) THEN
		CALL PRINT_ERROR ('ERROR IN CALCULATION OF TOTAL REWEIGHTING FACTOR.')
        	ERRORSTAT = .TRUE.
        	CALL MPI_ABORT (MPI_COMM_WORLD, MPIBIND, MPIERROR)
        	RETURN
	ENDIF
	C(1:NMTD / CDUMP + 1) = TEMP * DLOG (TCNUMER(1:NMTD / CDUMP) / TCDENOM(1:NMTD / CDUMP + 1))
	!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$!
	!#ENDIF
	RETURN
	END SUBROUTINE
	!*****************************************************************************************!

	!CHOOSES SUBORUTINE FOR PRINTING METADYNAMICS FREE ENEGRY SURFACE AS A FUNCTION OF COLLECTIVE VARIABES.
	SUBROUTINE PRINT_HILLS
	USE GLOBAL_VAR
	IMPLICIT NONE
	IF (NDIM .EQ. 1) CALL PRINT_HILLS_1D 
	RETURN
	END SUBROUTINE
        !*****************************************************************************************!

	!PRINTS THE 1-D METADYNAMICS FREE ENERGY AS A FUNCTON OF COLLECTIVE VARIABLES.
	SUBROUTINE PRINT_HILLS_1D
	USE GLOBAL_VAR
	IMPLICIT NONE
	INTEGER ITER1, IBIAS
	!OPENS OUTPUT FILE.
	OPEN (UNIT = 1, FILE = OUTPUTFILE1, STATUS = 'OLD')
	DO ITER1 = 1,NBIN(1)
	!SELECTS INDEX OF POINT ON GRID.
		I(1) = ITER1
	!FINDS THE GRID POINT.
		CALL GETS
	!PRINTS THE VALUE OF BIAS.
		WRITE(1,*) S(1), -WTALPHA * TBIAS(IBIAS ())
	ENDDO
	CLOSE(1)
	RETURN
	END SUBROUTINE
	
	!PRINTS REWEIGHTING FACTOR AS A FUNCTION OF METADYNAMICS STEPS.
	SUBROUTINE PRINT_C
	USE GLOBAL_VAR
	IMPLICIT NONE
	INTEGER ITER1
	OPEN (UNIT = 1, FILE = CFILE, STATUS = 'UNKNOWN')
	IF (MPIRANK .EQ. 0) THEN
		DO ITER1 = 1,NMTD / CDUMP
			WRITE(1,*) ITER1, C(ITER1)
		ENDDO
	ENDIF
	RETURN
	END SUBROUTINE
        !*****************************************************************************************!
	!>>>>>> SUBROUTINES <<<<<<<!
	!*****************************************************************************************!

